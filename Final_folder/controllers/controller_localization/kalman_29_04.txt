#include <stdio.h>
#include <string.h>
#include <math.h>
/** Kalman filter
  * Framework to estimate an unknown variable using a series of measurements containing noise.
  * Best possible linear estimator
  *
*/


#include "kalman.h"
int time_step;
static kalman_t kal_pos;
static double X[4];
static double K[4][2];
static double X_new[4];

double last_gps_time_ = 0.0f;

// Multiplies two matrices mat1[][] and mat2[][] // and returns result. // (m1) x (m2) and (n1) x (n2) are dimensions // of given matrices.
void multiply(int m1, int m2, const double mat1[][m2], int n1, int n2, const double mat2[][n2], double res[m1][n2]) {


    for (int i = 0; i < m1; i++) {
        for (int j = 0; j < n2; j++) {
            res[i][j] = 0;
            for (int k = 0; k < m2; k++) {
                *(*(res + i) + j) += *(*(mat1 + i) + k) * *(*(mat2 + k) + j);
            }
        }
    }
}

void add(int m1, int m2, const double mat1[][m2], const double mat2[][m2], double res[m1][m2], double scale) {


    for (int i = 0; i < m1; i++) {
        for (int j = 0; j < m2; j++) {
            //res[i][j] = 0;
            res[i][j] = mat1[i][j] + mat2[i][j] * scale;
        }
    }

}

void substract(int m1, int m2, const double mat1[][m2], const double mat2[][m2], double res[m1][m2]) {


    for (int i = 0; i < m1; i++) {
        for (int j = 0; j < m2; j++) {

            res[i][j] = mat1[i][j] - mat2[i][j];
        }
    }

}

double determinant(double mat[2][2]) {
    return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
}

void inverse(double mat[2][2], double mat_inv[2][2]) {

    double det = determinant(mat);

    mat_inv[0][0] = mat[1][1] / det;
    mat_inv[0][1] = -mat[0][1] / det;
    mat_inv[1][0] = -mat[1][0] / det;
    mat_inv[1][1] = mat[0][0] / det;

}




// Initilaize to zero
void compute_kalman(kalman_t* kal, const int time_step, double time_now, const double acc[3], const double acc_mean[3], const double gpsx, const double gpsy, const double heading) {

    // This is in robot frame.... Careful ! add the heading of wheel encoder
    double acc_wx = ( acc[1] - acc_mean[1]);
    double acc_wy = ( acc[0] - acc_mean[0]);
    double acceleration[2] = {acc_wx, -acc_wy};

    
    // True GPS pose
    double z[2] = {gpsx, gpsy};

    static const double dt = 0.016; // time step of 16ms

    
    // Covariance representing motion noise //quite robust with Kalman
    static double R[4][4] = {
            {0.05, 0,    0,    0},
            {0,    005, 0,    0},
            {0,    0,    0.01, 0},
            {0,    0,    0,    0.01}};

    // State uncertainty // trst and trial, with true and prediction
    static double Cov[4][4] = {
            {0.001, 0,     0,     0},
            {0,     0.001, 0,     0},
            {0,     0,     0.001, 0},
            {0,     0,     0,     0.001}};



    // Measurement model 
    static double C[2][4] = {{1, 0, 0, 0},
                             {0, 1, 0, 0}};
    
    // Covariance matrix, measurement noise
    static double Q[2][2] = {{1., 0.},
                             {0., 1.}};

    // Transposed of C matrix 
    static double C_trans[4][2] = {{1, 0},
                                   {0, 1},
                                   {0, 0},
                                   {0, 0}};_kal_wheel
    // Identity matrix
    static double Id4[4][4] = {{1, 0, 0, 0},
                               {0, 1, 0, 0},
                               {0, 0, 1, 0},
                               {0, 0, 0, 1}};

    // Motion/Process model
    static double A[4][4] = {
            {1, 0, dt, 0},
            {0, 1, 0,  dt},
            {0, 0, 1,  0},
            {0, 0, 0,  1}};

    // Doesn't change
    static double A_trans[4][4] = {_kal_wheel
            {1,  0,  0, 0},
            {0,  1,  0, 0},
            {dt, 0,  1, 0},
            {0,  dt, 0, 1}};

    // Control matrix
    static double B[4][2] = {
            {0,  0},
            {0,  0},
            {dt, 0},
            {0,  dt}};


    // double time_step = 0.016;


    double tmp1[4], tmp2[4], tmp3[2];
    double tmp4[4][4], tmp5[4][4], tmp6[4][4], tmp7[4][4];
    double tmp8[4][2], tmp9[2][2], tmp10[2][2];

    // Compute X_new wihtout GPS _kal_wheel

    
    multiply(4, 4, A, 4, 1, X, tmp1);


    multiply(4, 2, B, 2, 1, acceleration, tmp2);

    add(4, 1, tmp1, tmp2, X_new, 1);


    // Compute Cov_new without gps

    multiply(4, 4, A, 4, 4, Cov, tmp4);
    multiply(4, 4, tmp4, 4, 4, A_trans, tmp5);
    add(4, 4, tmp5, R, Cov, dt);


    // Using accelerometer and GPS  
    
    
  
    // Every second update using GPS pose 
    if (time_now - last_gps_time_ > 1.0f) {
      printf("Entered kalman:\n");
    
      last_gps_time_ = time_now;

      // Compute K
      multiply(4, 4, Cov, 4, 2, C_trans, tmp8); // D = Cov_new*C_trans
      multiply(2, 4, C, 4, 2, tmp8, tmp9); // Y = C* D = C*Cov_new*C_trans
      add(4, 4, tmp9, Q, tmp9, 1); // Y = Y + Q = C* D = C*Cov_new*C_trans + Q
      inverse(tmp9, tmp10); // inverse = inv(Y) = inv(C*Cov_new*C_trans)
      multiply(4, 2, tmp8, 2, 2, tmp10, K); // K = D* inv(C* D + Q)
  
  
      // Compute new X when gps available
      multiply(2, 4, C, 4, 1, X_new, tmp3); // tmp3 = C*X_new
      substract(4, 1, z, tmp3, tmp3); // tmp3 = z - C*X_new = z - tmp3
      printf("z_1 = %g , z_2 = %g \n", z[0], z[1]);
      multiply(4, 2, K, 2, 1, tmp3, tmp3); // tmp3 = K*tmp3 = K*(z - C*X_new)
      add(4, 1, tmp3, X_new, X_new, 1); // X_new = X_new + K*(z - C*X_new)
  
      // Compute new covariance matrix
      multiply(4, 2, K, 2, 4, C, tmp6); // tmp6 = K*C
      substract(4, 4, Id4, tmp6, tmp7); // tmp7 = eye(4) - K*C
      multiply(4, 4, Cov, 4, 4, tmp7, tmp6); // Cov_new = Cov_new*(eye(4) - K*C)
      // Assign to Cov the new values stored in tmp6
      for (int i = 0; i < 4; i++) 
          for (int j = 0; j < 4; j++)
              Cov[i][j] = tmp6[i][j];
       
      printf("Kalman : %g %g %g %g\n", kal->x , kal->y , kal->vx, kal->vy);
      }
  
      kal_pos.x = X_new[0];
      kal_pos.y = X_new[1];
      kal_pos.vx = X_new[2];
      kal_pos.vy = X_new[3];
      
      X[0] = X_new[0];
      X[1] = X_new[1];
      X[2] = X_new[2];
      X[3] = X_new[3];

      
      memcpy(kal, &kal_pos, sizeof(kalman_t));
      //printf("Kalman : %g %g %g %g\n", kal->x , kal->y , kal->vx, kal->vy);

}
